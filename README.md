# Итоговая работа по вводному блоку курса "Разработчик" студента Мухаметдинова Р.Р.
## Задача
 Написать программу, которая из имеющегося массива строк формирует новый строковый массив, длина элементов которого меньше, либо равна 3 символам. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

Примеры:
+ ___[“Hello”, “2”, “world”, “:-)”] → [“2”, “:-)”]___
+ ___[“1234”, “1567”, “-2”, “computer science”] → [“-2”]___
+ ___[“Russia”, “Denmark”, “Kazan”] → []___

Для решения поставленной задачи разобъем алгоритм её решения на следующие этапы:
1. Задание строки символов с консоли.
2. Получение строкового массива из строки.
3. Сортировка элементов, размер которых равен или меньше 3, в новый массив.
4. Печать отсортированного массива.

## Решение
Реализуем этапы решения решения задачи.
### 1. Основной метод `static void Main(string[] args) {...}` - точка входа в программу.
   ```sh
   static void Main(string[] args)
    {
        Console.InputEncoding = System.Text.Encoding.GetEncoding("utf-16");
        Console.WriteLine("Введите массив строк через запятую, завершите командами <Enter> и <Esc>:");

        string str1 = "";
        ConsoleKeyInfo keyInfo = new ConsoleKeyInfo();
        while (true)
        {
            str1 = Convert.ToString(Console.ReadLine());
            keyInfo = Console.ReadKey();

            if (keyInfo.Key == ConsoleKey.Escape)
            {
                break;
            }
        }
        string[] str = GetStringArrayFromConsole(str1);
        Console.Write("\nВы ввели массив строк: ");
        PrintArray(str);
        string[] newArray = GetSortedArray(str, x => x.ToCharArray().Length <= 3);
        Console.Write("Массив из строк, длина которых меньше, либо равна 3 символам: ");
        PrintArray(newArray);
    }
   ```   
   В моей программе предполагается задание строки символов с консоли. Причём задание будущего массива предписывает ввод символов через запятую в одну строку. Следовательно программа должна распознать в ведённой с консоли строке отдельные элементы между запятыми и сформировать массив строк.<br> 
   Консоль не распознаёт символы на Кириллице. Для этого нужного задать кодировку символов консоли в ___UTF-16___ с помощью метода `System.Text.Encoding Console.InputEncoding { get; set; }`:
   ```sh
   Console.InputEncoding = System.Text.Encoding.GetEncoding("utf-16");
   ```
   Для сохранения строки символов, введённых с консоли, зададим переменную типа ___string___:
   ```sh
   string str1 = "";
   ```
   Логику ввода строки символов реализуем в цикле ___while___, а выход из цикла - опреатором `break` по нажатию стандартной клавиши ***\<Esc>***:
   ```sh
   while (true)
        {
            str1 = Convert.ToString(Console.ReadLine());
                        
            /* If <Esc> key is pressed, break the while loop */
            
        }
   ```
   Ввод строки нужно прервать после окончания ввода строки символов. Для этого воспользуемся свойством `public ConsoleKey Key { get; }` структуры `ConsoleKeyInfo`, описывающую и возвращающую нажатую клавишу с консоли.   
   
   Для дотупа к  `public ConsoleKey Key { get; }` создадим новый объект типа `ConsoleKeyInfo`:
   ```sh
   ConsoleKeyInfo keyInfo = new ConsoleKeyInfo();
   ```
   Но для получения значения символа, введённого пользователем с клавиатуры, нужно через системный метод `Console.ReadKey()` считать символ с консоли и присвоить объекту `ConsoleKeyInfo`:
   ```sh
   keyInfo = Console.ReadKey();
   ```
   Теперь через свойство `public ConsoleKey Key { get; }`, в которое попадает значение символа с консоли, можно задать условие выхода с цикла `while` через сравнение значения `keyInfo.Key` со стандартным значением ***\<Esc>*** структуры типа перечисление `enum System.ConsoleKey`:
   ```sh
   while (true)
        {
            str1 = Convert.ToString(Console.ReadLine());
                        
            if (keyInfo.Key == ConsoleKey.Escape)
            {
                break;
            }
            
        }
   ```

   ### 2. Получение строкового массива из строки символов, введённых с консоли
   реализуем в методе `static string[] GetStringArrayFromConsoleString(string str1) {...}`:
   ```sh
   static string[] GetStringArrayFromConsoleString(string str1)
    {
        string[] str2 = str1.Split(',', StringSplitOptions.TrimEntries);
        return str2;
    }
   ```
   Метод принимает один параметр __str1__ типа ___string___. С помощью метода `String.Split(char <separator>, StringSplitOptions.TrimEntries)`, который удаляет пробелы (если есть таковые) по обе стороы от набора символов в __str1__ и возвращает строковый массив из подстрок __str1__, разделённых символом, указанным в первом параметре `String.Split(<params>)`, то есть разделённх запятыми.

   ### 3. Печать строкового массива в консоль
   реализуем в методе `static void PrintArray(string[] str) {...}`:
   ```sh
   static void PrintArray(string[] str)
    {
        string str2 = (str.Length == 0) ? "[]" : "[\"" + String.Join("\", \"", str) + "\"]";
        Console.WriteLine(str2);
    }
   ```
   Здесь реализован формат вывода и вывод на консоль строкового массива.
   Метод `String.Join(string <separator>, string[] <value>)` формирует строку из массива строк, разделённых символом, указанным в первом параметре метода.

   ### 4. Сортировку строкового массива, возвращающего новый массив с элементами меньшими или равными 3
   реализуем в методе `static string[] GetSortedArray(string[] str, Predicate predicate) {...}`:
   ```sh
   delegate bool Predicate(string str);

   static string[] GetSortedArray(string[] str, Predicate predicate)
    {
        string[] str2 = new string[1];
        for (int i = 0; i < str.GetLength(0); i++)
        {
            if (predicate(str[i]))
            {
                str2[str2.Length - 1] = str[i];
                Array.Resize(ref str2, str2.Length + 1);
            }
        }
        Array.Resize(ref str2, str2.Length - 1);

        return str2;
    }
   ```
   #### *1. Метод-делегат*.
   Данный метод принимает два параметра: строковый массив для дальнейшей сортировки и объект-делегат, указывающий на анонимную функцию-предикату (возвращающую **true** или **false**).\
   Делегаты - это указатели на анонимные методы, и с помощью делегатов мы можем объявлять и вызывать методы прямо в списке параметров.
   Для вызова метода-делегата нужно сначало объявить тип самого делегата:
   ```sh
   delegate bool Predicate(string str);
   ``` 
   \- а в списке параметров нашей функции сортировки вторым параметром указываем имя делегата как тип и условное имя параметра:
   `Predicate predicate`.<br>
   Делегат, обычно объявляется до метода, в котором он вызывается, и состоит из ключевого слова `delegate`, после которого идет возвращаемый тип (в нашем случае - ___bool___), названиея `Predicate` и параметра `string str`. То есть делегат указывает на любую анонимную функцию, принимающую один параметр `string str` и возвращающую тип ___bool___.<br>
   В теле нашей функции `static string[] GetSortedArray(string[] str, Predicate predicate) {...}` реализоаван алгоритм сортировки строкового массива: в условии задачи сказано, что ___программа, должна из имеющегося массива строк формировать новый строковый массив, длина элементов которых меньше, либо равна 3 символам.___ 
   Для этого каждый элемент строкового массива в цикле будем переводить в символьный массив с помощью метода `String.ToCharArray()` и вычислять его длину на проверку условия: ___меньше, либо равна 3 символам___ - с помощью свойства массивов ___Length___:
   ```sh
   for (int i = 0; i < str.GetLength(0); i++)
        {
            if (str[i].ToCharArray().Length <= 3)
            {
                /* sorting algorithm */
            }
        }
   ```
   Но мы используем функцию-делегат в качестве второго параметра в нашей функции сортировки. Следовательно, алгоритм сортировки примет следующий вид:
   ```sh
   for (int i = 0; i < str.GetLength(0); i++)
        {
            if (predicate(str[i]))
            {
                /* sorting algorithm */
            }
        }
   ```
   Это потому, что делегат указывает на любую анонимную функцию, принимающую параметр `string str` и возвращающую тип ___bool___, как уже описывалось выше.\
   Так как же нам реализовать функцию-предикату касаемо нашей задачи:  `if (str[i].ToCharArray().Length <= 3) {/* sorting algorithm */}`???\
   В случае с делегатами это реализуется при вызове функции сортировки `static string[] GetSortedArray(string[] str, Predicate predicate) {...}`:
   ```sh
   string[] newArray = GetSortedArray(str, x => x.ToCharArray().Length <= 3);
   ```
   Здесь запись `x => x.ToCharArray().Length <= 3` и является формой объявления и вызова анонимной функции через лямбда-выражение (с помощью лямбда-оператора __=>__), где `x` до лямбда-оператора характеризует список параметров, принимаемых делегатом (`string str`), а инструкция после - тело анонимной функции, возвращающей **bool**.\
   Для чего такие сложности с делегатами??? Дело в том, что раз уж делегат указывает **"на любую анонимную функцию, принимающую параметр `string str` и возвращающую тип _bool_"**, то мы можем при вызове функции сортировки `static string[] GetSortedArray(string[] str, Predicate predicate) {...}` прописать любое выражение сортировки, например:
   ```sh
   string[] newArray = GetSortedArray(str, x => x.ToCharArray().Length >= 5);
   ```
   или, например:
   ```sh
   string[] newArray = GetSortedArray(str, x => int.TryParse(x, out int a) == true);
   ```
   Во втором примере в __GetSortedArray__ метод `int.TryParse` преобразует строку в 32-разрядное целое число со знаком. Возвращаемое значение типа **bool** указывает, выполнена ли операция успешно. То есть можно отсортировать целые числа.<br>
   В ___/* sorting algorithm */___ по условию `if (predicate(str[i]))` формируется новый массив строк отсортированных элементов.

   #### *2. Алгоритм сортировки*.
   Теперь разберёмся непосредственно с алгоритмом сортировки.\
   Заранее размерность нового массива строк `string[] str2` для отсортированных элементов неизвестна, т.к. неизвестно какой массив строк сформируется пользователем с консоли. Поэтому воспользуемся методом `Array.Resize<string>(ref string[] array, int newSize)`: данный метод позволяет динамически менять размер массива с помощью указания модификатора `ref` перед типом данных первого параметра метода.<br> 
   Исходя из вышеописанного зададим начальную размероность массива - т.к. она будет меняться - с одним элементом:
   ```sh
   string[] str2 = new string[1];
   ```
  Алгоритм формирования нового массива отсортированных строк реализуется с помощью инкрементации второго параметра метода `Array.Resize<string>(ref string[] array, int newSize)` при каждом выполнении условия `if (predicate(str[i])) {...}`
   ```sh
   str2[str2.Length - 1] = str[i];
   Array.Resize(ref str2, str2.Length + 1);
   ```
   После выполнения цикла ___for___ выполним инструкцию `Array.Resize(ref str2, str2.Length - 1);` для исключения пустой подстроки, появляющейся в отсортированном массиве в результате нажатия на ___\<Enter>___ после ввода пользователем строки символов с консоли.